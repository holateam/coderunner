CodeRunner service 
------------------

### Node.js server

Постоянно работающий сервер, написанный на языке Javascript, запускается интерпритатором Node. Организован как системный сервис (можно использовать пакет forever-service).
Модуль отвечает за прием и обработку REST запросов на тестирование пользовательского кода.

Полученные запросы валидируются сервером и отправляются в сервер архива запросов.

Сервер должен взаимодействать с внешним сервером логирования и рассылки.
Все входящие запросы, все подозрительные секции, найденные в коде, все внутренние системные ошибки должны логироватся на удаленном сервере. Некоторые, особо критичные случаи должны быть отправлены с флагом ```broadcast``` для рассылки почтовых уведомлений администраторам.
Отвалидированный  код отправляется обработчику очереди запуска задач.

Очередь запуска задач представляет собой отедльный модуль на языке Node.js. Делает следующие действия: при поступлении задачи на вход, она проверяет возможность отправки её на скрипт запуска. В случае, если количество запущенных скриптов максимально заданной конфигурацией, очередь оставляет задачу в памяти, лжидая момента, когда поступит комманда на освобождение места в очереди.

Сервер принимает следующие запросы:
***
**Запрос на проведение тестирования**
```
	Метод : POST
	Путь : /isolatedTest
	Тело : 
	{
		code: “”,
		language: “”,
		testCases: [ “stdIn 1”, “stdIn 2” ]
	}
```
**Формат ответа на запрос**
```
	Код ответа : 200 (запрос принят) / 400 (запрос отклоняется из за переполнения очереди)
	Тело : 
	{
		compiler errors: "",
		stdout : [ “testcase1 otp”, “testcase2 otp” ],
		stderr : [ “testcase1 err”, “testcase2 err” ],
		timestamps : [ “testcase1 duration”, “testcase2 duration” ]
	}
```
***
**Запрос на обработку результатов тестирования**
*Будет сформирован и отправлен ответ на запрос тестирования* из скрипта запуска Docker'a после завершения работы контейнера.
```
	Метод : GET
	Путь : /analyseTest/:<sessionID>
```
**Формат ответа на запрос**
```
	Код ответа : 200
	Тело : { data : null }
```
##Работа очереди запуска задач

Очередь принимает на вход обьект задачи, содержащий следующие свойства:
{
  taskId: .....,
  lang: ...,
  sourceCode: "...",
  testCases:["..","..",...]
}

Очередь отправялет задачи скрипту запуска по мере освобождения. Комманда освоождения приходит от сервера js в виде вызова метода taskFinished(taskId). Перед отправкой задания на скрипт запуска, мы создаем папку с именем taskId в общей папке для сервера и docker'a. Выгружаем в неё два файла: файл с кодом для компиляции и файл с тесткейсом.

Скрипт запуска докер-контейнеров принимает на вход taskId и маркер языка программирования. В зависимости от языка программирования, выбирается соответствующий image для запуска в докере, и производится запуск докера с выбранным контейнером. При запуске мы передаем докеру параметры, ограничивающие время работы программы пользователя, блокируем доступ во внешнюю сеть и расшариваем папки. По авершению работы контейнера, скрипт отправляет серверу Node.js запрос GET с помощью curl, сообщающий какой процесс завершен. В случае crash контейнера, дополнительно сообщает об этом модулю отправки alarm'ов.

###Докер-контейнер

Принимает на вход имя bash-скрипта, для выполнения внутри, и taskId вторым параметром. Bash-скрипт переходит переходит в папку с именем taskIdи запускает в ней компиляцию файла с исходным кодом пользователя. Процесс компиляции логируется в файле  в папке output с именем logCompileю В случае успешной компиляции, производится запуск откомпелированного файла, с передаче ему через pipe файла с тесткейсом. Результат работы каждого тесткейса сохраняется в папке output в файле testCaseLog. Дополнительно докер-контейнер контролировать обьем выгруженных в std-out данных, что бы исключить переполнение.

Сервер Node при получении GET запроса, сообщающего, что докер завершил работу контейнера, отправляет комманду очереди на освобождение одногом места, и запускает модуль анализатора логов. После обработки, анализатор логов формирует в памяти обьект ответа. По завершению проивзодим отправку результата на искходный response.

###Анализатор логов

Проивзодит чтение лог файлов отработавшего докер-контейнера и формирует на выходе ответ:
```
	{
		compiler errors: "",
		stdout : [ “testcase1 otp”, “testcase2 otp” ],
		stderr : [ “testcase1 err”, “testcase2 err” ],
		timestamps : [ “testcase1 duration”, “testcase2 duration” ]
	}
```

###Конфиг-файл сервера

Регулируется размер очереди, количество одновременно запущенных докер-контейнеров, макс количество входящих запросов в минуту, макс количество строк кода, перечень email длф отправки alarm, имя лог-файла

Сервер должен ограничивать количество запросов на компиляцию для каждого пользователя.
Запросы принимаются исключительно от доверенных серверов. Остальные -- игнорируются.

После приема и подтверждения запроса выполняются следующие действия:
- Генерирование случайного идентификатора ```sessionId``` для сессии тестирования.
- Санитаризация входящего кода.
- Подготовка общей директории для виртуальной машины и хоста ```~/.coderunner/sessionId```.
- Помещение конфигураций докера в файл ```~/.coderunner/sessionId/config```
- Создание в директории ```~/.coderunner/sessionId/input``` файлов ```source.x``` с исходным кодом, где x - соотествующее языку програмирования расширение и ```testcases```, который стостоит из строк входных данных для последоватлеьного тестирования.
- Добавление контейнера в очередь на выполнение.


### Модуль санитаризации кода

Клас со статическим методом, который принимает параметром строку с кодом и маркер языка.
Результат работы метода -- список обнаруженных нарушений в коде в виде массива:
```
[
	{
		line: 0, 			(номер линии с нарушением)
		danger-level: 0, 	(уровень опасности, чем выше -- тем хуже)
		text: "",			(строка с нарушением)
		comment: ""			(описание обнаруженного нарушения)
	}, ... {}
]
```

### Сервер логирования и рассылки

Сервер отвечает за логирование (записть в базу) приходящие на него месседжы, и отправлять на зарезервированные адреса письма, при необходимости. Необходимость определяется специальным флагом запроса к серверу.
При возникновении внутренних о

Сервер принимает запросы:

***
**Запрос на логирование**
```
	Метод : POST
	Путь : /log
	Тело : {
		user : "",
		type : info / warning / error / breach,
		broadcast : true / false
	}
```
**Формат ответа на запрос**
```
	Код ответа : 200 (если сервер принял и обработал запрос) / 400 (если возникли ошибки и сообщение не сохранено в базу)
```
***

### docker-handler.sh

Комманда получает единственным аргумментом sessionId, это позволяет найти соответствующую сессии директорию, прочитать файл конфигураций и запустить Docker контейнер с нужными параметрами.
Скрипт должен ожидать уничтожения контейнера (```bash wait```), после чего подавать запрос на REST API на обработку результатов выполнения (```curl localhost/analyseTest/:sessionId```).

### install.sh

Скрипт развертки приложения CodeRunner.
Скрипт должен удостоверить наличие на сервере необходимых пакетов (```which```), и в случае их отсутствия: установить.
Необходимые пакеты: node, npm, forever, forever-service, остальные модули, curl, docker, файлы node сервера, образы Docker контейнеров.

### Внутренние Bash скрипты для Docker

```сompiler.sh```
input: файл с кодом пользователя (с валидным расширением)
output: комманда для выполнения

```tester.sh```
input: файл с тесткейсами, комманда для выполнения
output: файлы с результатами тестирования
